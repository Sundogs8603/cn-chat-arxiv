{
    "title": "Implementing Dynamic Programming in Computability Logic Web. (arXiv:2304.01539v1 [cs.AI])",
    "abstract": "We present a novel definition of an algorithm and its corresponding algorithm language called CoLweb. The merit of CoLweb [1] is that it makes algorithm design so versatile. That is, it forces us to a high-level, proof-carrying, distributed-style approach to algorithm design for both non-distributed computing and distributed one. We argue that this approach simplifies algorithm design. In addition, it unifies other approaches including recursive logical/functional algorithms, imperative algorithms, object-oriented imperative algorithms, neural-nets, interaction nets, proof-carrying code, etc. As an application, we refine Horn clause definitions into two kinds: blind-univerally-quantified (BUQ) ones and parallel-universally-quantified (PUQ) ones. BUQ definitions corresponds to the traditional ones such as those in Prolog where knowledgebase is $not$ expanding and its proof procedure is based on the backward chaining. On the other hand, in PUQ definitions, knowledgebase is $expanding$ an",
    "link": "http://arxiv.org/abs/2304.01539",
    "context": "Title: Implementing Dynamic Programming in Computability Logic Web. (arXiv:2304.01539v1 [cs.AI])\nAbstract: We present a novel definition of an algorithm and its corresponding algorithm language called CoLweb. The merit of CoLweb [1] is that it makes algorithm design so versatile. That is, it forces us to a high-level, proof-carrying, distributed-style approach to algorithm design for both non-distributed computing and distributed one. We argue that this approach simplifies algorithm design. In addition, it unifies other approaches including recursive logical/functional algorithms, imperative algorithms, object-oriented imperative algorithms, neural-nets, interaction nets, proof-carrying code, etc. As an application, we refine Horn clause definitions into two kinds: blind-univerally-quantified (BUQ) ones and parallel-universally-quantified (PUQ) ones. BUQ definitions corresponds to the traditional ones such as those in Prolog where knowledgebase is $not$ expanding and its proof procedure is based on the backward chaining. On the other hand, in PUQ definitions, knowledgebase is $expanding$ an",
    "path": "papers/23/04/2304.01539.json",
    "total_tokens": 873,
    "translated_title": "在可计算逻辑 Web 中实现动态规划",
    "translated_abstract": "我们提出了一种新的算法定义及其相应的算法语言 CoLweb。CoLweb 的优点在于它使得算法设计更加灵活，强制我们采用高层次、证明携带，分布式风格的算法设计方法，适用于分布式与非分布式计算。我们认为，这种方法简化了算法设计，并将其他方法统一起来，包括递归逻辑/函数算法、命令式算法、面向对象的命令式算法、神经网络、交互式网络、证明携带代码等。作为应用，我们将 Horn 子句定义细化为两种类型：盲量化的全量化定义（BUQ）和并行量化的全量化定义（PUQ）。BUQ 定义对应于传统的定义，例如 Prolog 中的定义，其中知识库不会扩展，其证明过程基于向后链接。另一方面，在 PUQ 定义中，知识库正在扩展。",
    "tldr": "CoLweb是一种优秀的算法语言，可以通过高层次、证明携带，分布式风格的方法统一多种算法设计方法，而且在Horn子句定义细化方面有很好的应用。",
    "en_tdlr": "CoLweb is an excellent algorithm language that unifies multiple algorithm design methods through a high-level, proof-carrying, distributed-style approach, and has good applications in refining Horn clause definitions."
}