{
    "title": "Statement-based Memory for Neural Source Code Summarization. (arXiv:2307.11709v1 [cs.AI])",
    "abstract": "Source code summarization is the task of writing natural language descriptions of source code behavior. Code summarization underpins software documentation for programmers. Short descriptions of code help programmers understand the program quickly without having to read the code itself. Lately, neural source code summarization has emerged as the frontier of research into automated code summarization techniques. By far the most popular targets for summarization are program subroutines. The idea, in a nutshell, is to train an encoder-decoder neural architecture using large sets of examples of subroutines extracted from code repositories. The encoder represents the code and the decoder represents the summary. However, most current approaches attempt to treat the subroutine as a single unit. For example, by taking the entire subroutine as input to a Transformer or RNN-based encoder. But code behavior tends to depend on the flow from statement to statement. Normally dynamic analysis may she",
    "link": "http://arxiv.org/abs/2307.11709",
    "context": "Title: Statement-based Memory for Neural Source Code Summarization. (arXiv:2307.11709v1 [cs.AI])\nAbstract: Source code summarization is the task of writing natural language descriptions of source code behavior. Code summarization underpins software documentation for programmers. Short descriptions of code help programmers understand the program quickly without having to read the code itself. Lately, neural source code summarization has emerged as the frontier of research into automated code summarization techniques. By far the most popular targets for summarization are program subroutines. The idea, in a nutshell, is to train an encoder-decoder neural architecture using large sets of examples of subroutines extracted from code repositories. The encoder represents the code and the decoder represents the summary. However, most current approaches attempt to treat the subroutine as a single unit. For example, by taking the entire subroutine as input to a Transformer or RNN-based encoder. But code behavior tends to depend on the flow from statement to statement. Normally dynamic analysis may she",
    "path": "papers/23/07/2307.11709.json",
    "total_tokens": 838,
    "translated_title": "基于语句的记忆神经源代码摘要化",
    "translated_abstract": "源代码摘要化是将源代码行为写成自然语言描述的任务。代码摘要化为程序员提供了软件文档的基础。代码的简短描述可以帮助程序员快速理解程序，而不必阅读代码本身。近年来，神经源代码摘要化已经成为自动化代码摘要化技术研究的前沿。到目前为止，最受欢迎的摘要化目标是程序子程序。简而言之，就是使用从代码仓库中提取的大量子程序示例来训练编码器-解码器神经架构。编码器表示代码，解码器表示摘要。然而，大多数当前方法尝试将子程序视为单个单位。例如，通过将整个子程序作为输入传递给Transformer或基于RNN的编码器。但代码行为往往取决于语句之间的流动。通常可以通过动态分析来进行评估",
    "tldr": "该论文研究了基于语句的记忆神经源代码摘要化。当前的方法往往将子程序作为单个单位处理，但事实上代码的行为取决于语句之间的流动。",
    "en_tdlr": "This paper investigates statement-based memory for neural source code summarization. Current approaches often treat subroutines as individual units, but in reality, the behavior of code depends on the flow of statements."
}