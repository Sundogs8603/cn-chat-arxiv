{
    "title": "Local Grammar-Based Coding Revisited. (arXiv:2209.13636v2 [cs.IT] UPDATED)",
    "abstract": "We revisit the problem of minimal local grammar-based coding. In this setting, the local grammar encoder encodes grammars symbol by symbol, whereas the minimal grammar transform minimizes the grammar length in a preset class of grammars as given by the length of local grammar encoding. It has been known that such minimal codes are strongly universal for a strictly positive entropy rate, whereas the number of rules in the minimal grammar constitutes an upper bound for the mutual information of the source. Whereas the fully minimal code is likely intractable, the constrained minimal block code can be efficiently computed. In this article, we present a new, simpler, and more general proof of strong universality of the minimal block code, regardless of the entropy rate. The proof is based on a simple Zipfian bound for ranked probabilities. By the way, we also show empirically that the number of rules in the minimal block code cannot clearly discriminate between long-memory and memoryless s",
    "link": "http://arxiv.org/abs/2209.13636",
    "context": "Title: Local Grammar-Based Coding Revisited. (arXiv:2209.13636v2 [cs.IT] UPDATED)\nAbstract: We revisit the problem of minimal local grammar-based coding. In this setting, the local grammar encoder encodes grammars symbol by symbol, whereas the minimal grammar transform minimizes the grammar length in a preset class of grammars as given by the length of local grammar encoding. It has been known that such minimal codes are strongly universal for a strictly positive entropy rate, whereas the number of rules in the minimal grammar constitutes an upper bound for the mutual information of the source. Whereas the fully minimal code is likely intractable, the constrained minimal block code can be efficiently computed. In this article, we present a new, simpler, and more general proof of strong universality of the minimal block code, regardless of the entropy rate. The proof is based on a simple Zipfian bound for ranked probabilities. By the way, we also show empirically that the number of rules in the minimal block code cannot clearly discriminate between long-memory and memoryless s",
    "path": "papers/22/09/2209.13636.json",
    "total_tokens": 912,
    "translated_title": "本文重新审视了局部基于语法的编码问题",
    "translated_abstract": "本文重新审视了最小局部基于语法的编码问题。在这个设置中，局部基于语法的编码器逐个符号地对语法进行编码，而最小语法变换通过局部语法编码的长度在预设的语法类别中最小化语法长度。已知，这样的最小编码对于严格正熵率的情况具有强大的普遍性，而最小语法中的规则数量构成了源的互信息的上界。尽管完全最小编码可能是不可行的，但受限的最小分块编码可以有效计算。本文提出了一种新的、更简单、更普适的最小分块编码强大普遍性的证明方法，不受熵率的限制。该证明基于对排名概率的简单的Zipfian界限。顺便提一下，我们还通过实验证明，最小分块编码中的规则数量不能明确区分长记忆和无记忆的源。",
    "tldr": "本文重新审视了最小局部基于语法的编码问题，并提出了一种新的、更简单、更普遍的证明方法，证明了最小分块编码具有强大的普遍性。同时，通过实验也表明，最小分块编码中的规则数量不能明确区分长记忆和无记忆的源。"
}