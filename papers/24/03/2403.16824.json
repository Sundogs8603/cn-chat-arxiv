{
    "title": "On Policy Reuse: An Expressive Language for Representing and Executing General Policies that Call Other Policies",
    "abstract": "arXiv:2403.16824v1 Announce Type: new  Abstract: Recently, a simple but powerful language for expressing and learning general policies and problem decompositions (sketches) has been introduced in terms of rules defined over a set of Boolean and numerical features. In this work, we consider three extensions of this language aimed at making policies and sketches more flexible and reusable: internal memory states, as in finite state controllers; indexical features, whose values are a function of the state and a number of internal registers that can be loaded with objects; and modules that wrap up policies and sketches and allow them to call each other by passing parameters. In addition, unlike general policies that select state transitions rather than ground actions, the new language allows for the selection of such actions. The expressive power of the resulting language for policies and sketches is illustrated through a number of examples.",
    "link": "https://arxiv.org/abs/2403.16824",
    "context": "Title: On Policy Reuse: An Expressive Language for Representing and Executing General Policies that Call Other Policies\nAbstract: arXiv:2403.16824v1 Announce Type: new  Abstract: Recently, a simple but powerful language for expressing and learning general policies and problem decompositions (sketches) has been introduced in terms of rules defined over a set of Boolean and numerical features. In this work, we consider three extensions of this language aimed at making policies and sketches more flexible and reusable: internal memory states, as in finite state controllers; indexical features, whose values are a function of the state and a number of internal registers that can be loaded with objects; and modules that wrap up policies and sketches and allow them to call each other by passing parameters. In addition, unlike general policies that select state transitions rather than ground actions, the new language allows for the selection of such actions. The expressive power of the resulting language for policies and sketches is illustrated through a number of examples.",
    "path": "papers/24/03/2403.16824.json",
    "total_tokens": 820,
    "translated_title": "关于策略重用：一种用于表示和执行调用其他策略的通用策略的表达语言",
    "translated_abstract": "最近，一种旨在通过在一组布尔和数值特征上定义的规则来表达和学习通用策略和问题分解（草图）的简单而强大的语言已经被引入。本文考虑了此语言的三个扩展，旨在使策略和草图更加灵活和可重用：内部存储状态，类似于有限状态控制器; 索引特征，其值是状态和一些可装入对象的内部寄存器数量的函数; 以及封装策略和草图的模块，并允许它们通过传递参数相互调用。此外，与选择状态转换而不是基础动作的通用策略不同，新语言允许选择这些动作。通过一些示例展示了所得到的用于策略和草图的语言的表现力。",
    "tldr": "一种表达通用策略和问题分解的语言引入了内部存储状态、索引特征和模块扩展，使得策略和草图更加灵活和可重用。",
    "en_tdlr": "A language for expressing general policies and problem decompositions has been extended with internal memory states, indexical features, and modules, making policies and sketches more flexible and reusable."
}